/* 
 * AIcrowd Evaluations API
 *
 * API to create and evaluate custom challenges on AIcrowd!
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Cluster {
  /// ID
  #[serde(rename = "id")]
  id: Option<i32>,
  /// Creation time
  #[serde(rename = "created")]
  created: Option<String>,
  /// Last updation time
  #[serde(rename = "updated")]
  updated: Option<String>,
  /// Remote address used to connect to the cluster
  #[serde(rename = "remote_address")]
  remote_address: String,
  /// Authentication needed for the cluster
  #[serde(rename = "auth_token")]
  auth_token: String,
  /// Docker registry username
  #[serde(rename = "docker_username")]
  docker_username: String,
  /// Docker registry URL. Dockerhub is used by default.
  #[serde(rename = "docker_registry")]
  docker_registry: Option<String>,
  /// Kubernetes namespace to run the workflows in
  #[serde(rename = "namespace")]
  namespace: Option<String>,
  /// Storage class to use for datasets
  #[serde(rename = "storage_class")]
  storage_class: Option<String>,
  /// Readiness of the cluster
  #[serde(rename = "status")]
  status: Option<bool>,
  /// Name of the workflow used to setup grader
  #[serde(rename = "wf_name")]
  wf_name: Option<String>,
  /// External IP exposed by LoadBalancer Service of argo-server deployment
  #[serde(rename = "argo_host")]
  argo_host: Option<String>,
  /// Argo server token required for authentication
  #[serde(rename = "argo_token")]
  argo_token: Option<String>,
  /// User ID
  #[serde(rename = "user_id")]
  user_id: Option<i32>,
  /// Organisation ID
  #[serde(rename = "organisation_id")]
  organisation_id: Option<i32>
}

impl Cluster {
  pub fn new(remote_address: String, auth_token: String, docker_username: String) -> Cluster {
    Cluster {
      id: None,
      created: None,
      updated: None,
      remote_address: remote_address,
      auth_token: auth_token,
      docker_username: docker_username,
      docker_registry: None,
      namespace: None,
      storage_class: None,
      status: None,
      wf_name: None,
      argo_host: None,
      argo_token: None,
      user_id: None,
      organisation_id: None
    }
  }

  pub fn set_id(&mut self, id: i32) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i32) -> Cluster {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i32> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_created(&mut self, created: String) {
    self.created = Some(created);
  }

  pub fn with_created(mut self, created: String) -> Cluster {
    self.created = Some(created);
    self
  }

  pub fn created(&self) -> Option<&String> {
    self.created.as_ref()
  }

  pub fn reset_created(&mut self) {
    self.created = None;
  }

  pub fn set_updated(&mut self, updated: String) {
    self.updated = Some(updated);
  }

  pub fn with_updated(mut self, updated: String) -> Cluster {
    self.updated = Some(updated);
    self
  }

  pub fn updated(&self) -> Option<&String> {
    self.updated.as_ref()
  }

  pub fn reset_updated(&mut self) {
    self.updated = None;
  }

  pub fn set_remote_address(&mut self, remote_address: String) {
    self.remote_address = remote_address;
  }

  pub fn with_remote_address(mut self, remote_address: String) -> Cluster {
    self.remote_address = remote_address;
    self
  }

  pub fn remote_address(&self) -> &String {
    &self.remote_address
  }


  pub fn set_auth_token(&mut self, auth_token: String) {
    self.auth_token = auth_token;
  }

  pub fn with_auth_token(mut self, auth_token: String) -> Cluster {
    self.auth_token = auth_token;
    self
  }

  pub fn auth_token(&self) -> &String {
    &self.auth_token
  }


  pub fn set_docker_username(&mut self, docker_username: String) {
    self.docker_username = docker_username;
  }

  pub fn with_docker_username(mut self, docker_username: String) -> Cluster {
    self.docker_username = docker_username;
    self
  }

  pub fn docker_username(&self) -> &String {
    &self.docker_username
  }


  pub fn set_docker_registry(&mut self, docker_registry: String) {
    self.docker_registry = Some(docker_registry);
  }

  pub fn with_docker_registry(mut self, docker_registry: String) -> Cluster {
    self.docker_registry = Some(docker_registry);
    self
  }

  pub fn docker_registry(&self) -> Option<&String> {
    self.docker_registry.as_ref()
  }

  pub fn reset_docker_registry(&mut self) {
    self.docker_registry = None;
  }

  pub fn set_namespace(&mut self, namespace: String) {
    self.namespace = Some(namespace);
  }

  pub fn with_namespace(mut self, namespace: String) -> Cluster {
    self.namespace = Some(namespace);
    self
  }

  pub fn namespace(&self) -> Option<&String> {
    self.namespace.as_ref()
  }

  pub fn reset_namespace(&mut self) {
    self.namespace = None;
  }

  pub fn set_storage_class(&mut self, storage_class: String) {
    self.storage_class = Some(storage_class);
  }

  pub fn with_storage_class(mut self, storage_class: String) -> Cluster {
    self.storage_class = Some(storage_class);
    self
  }

  pub fn storage_class(&self) -> Option<&String> {
    self.storage_class.as_ref()
  }

  pub fn reset_storage_class(&mut self) {
    self.storage_class = None;
  }

  pub fn set_status(&mut self, status: bool) {
    self.status = Some(status);
  }

  pub fn with_status(mut self, status: bool) -> Cluster {
    self.status = Some(status);
    self
  }

  pub fn status(&self) -> Option<&bool> {
    self.status.as_ref()
  }

  pub fn reset_status(&mut self) {
    self.status = None;
  }

  pub fn set_wf_name(&mut self, wf_name: String) {
    self.wf_name = Some(wf_name);
  }

  pub fn with_wf_name(mut self, wf_name: String) -> Cluster {
    self.wf_name = Some(wf_name);
    self
  }

  pub fn wf_name(&self) -> Option<&String> {
    self.wf_name.as_ref()
  }

  pub fn reset_wf_name(&mut self) {
    self.wf_name = None;
  }

  pub fn set_argo_host(&mut self, argo_host: String) {
    self.argo_host = Some(argo_host);
  }

  pub fn with_argo_host(mut self, argo_host: String) -> Cluster {
    self.argo_host = Some(argo_host);
    self
  }

  pub fn argo_host(&self) -> Option<&String> {
    self.argo_host.as_ref()
  }

  pub fn reset_argo_host(&mut self) {
    self.argo_host = None;
  }

  pub fn set_argo_token(&mut self, argo_token: String) {
    self.argo_token = Some(argo_token);
  }

  pub fn with_argo_token(mut self, argo_token: String) -> Cluster {
    self.argo_token = Some(argo_token);
    self
  }

  pub fn argo_token(&self) -> Option<&String> {
    self.argo_token.as_ref()
  }

  pub fn reset_argo_token(&mut self) {
    self.argo_token = None;
  }

  pub fn set_user_id(&mut self, user_id: i32) {
    self.user_id = Some(user_id);
  }

  pub fn with_user_id(mut self, user_id: i32) -> Cluster {
    self.user_id = Some(user_id);
    self
  }

  pub fn user_id(&self) -> Option<&i32> {
    self.user_id.as_ref()
  }

  pub fn reset_user_id(&mut self) {
    self.user_id = None;
  }

  pub fn set_organisation_id(&mut self, organisation_id: i32) {
    self.organisation_id = Some(organisation_id);
  }

  pub fn with_organisation_id(mut self, organisation_id: i32) -> Cluster {
    self.organisation_id = Some(organisation_id);
    self
  }

  pub fn organisation_id(&self) -> Option<&i32> {
    self.organisation_id.as_ref()
  }

  pub fn reset_organisation_id(&mut self) {
    self.organisation_id = None;
  }

}



