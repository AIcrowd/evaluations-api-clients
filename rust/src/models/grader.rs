/* 
 * Evaluations API
 *
 * API to create and evaluate custom challenges
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct Grader {
  /// ID
  #[serde(rename = "id")]
  id: Option<i32>,
  /// Creation time
  #[serde(rename = "created")]
  created: Option<String>,
  /// Last updation time
  #[serde(rename = "updated")]
  updated: Option<String>,
  /// S3 link of the Dataset
  #[serde(rename = "dataset_url")]
  dataset_url: Option<String>,
  /// git/http
  #[serde(rename = "code_access_mode")]
  code_access_mode: String,
  /// Cluster to run the grader on
  #[serde(rename = "cluster_id")]
  cluster_id: Option<i32>,
  /// Docker registry username
  #[serde(rename = "docker_username")]
  docker_username: String,
  /// Docker registry password
  #[serde(rename = "docker_password")]
  docker_password: String,
  /// Docker registry URL. Dockerhub is used by default.
  #[serde(rename = "docker_registry")]
  docker_registry: Option<String>,
  /// Argo workflow template spec
  #[serde(rename = "workflow_spec")]
  workflow_spec: Option<Value>,
  /// S3 link to the zip file containing the code that will be used for the evaluation
  #[serde(rename = "evaluation_code")]
  evaluation_code: String,
  /// Size of the dataset partition to request. Please provide at least 2x of the size of the dataset.
  #[serde(rename = "storage_capacity")]
  storage_capacity: Option<String>,
  /// Logs from argo workflow
  #[serde(rename = "logs")]
  logs: Option<Value>,
  /// Additional meta data of the grader
  #[serde(rename = "meta")]
  meta: Option<Value>,
  /// Status of the grader - True if it ready, False otherwise
  #[serde(rename = "status")]
  status: Option<bool>,
  /// User ID
  #[serde(rename = "user_id")]
  user_id: Option<i32>,
  /// Organisation ID
  #[serde(rename = "organisation_id")]
  organisation_id: Option<i32>
}

impl Grader {
  pub fn new(code_access_mode: String, docker_username: String, docker_password: String, evaluation_code: String) -> Grader {
    Grader {
      id: None,
      created: None,
      updated: None,
      dataset_url: None,
      code_access_mode: code_access_mode,
      cluster_id: None,
      docker_username: docker_username,
      docker_password: docker_password,
      docker_registry: None,
      workflow_spec: None,
      evaluation_code: evaluation_code,
      storage_capacity: None,
      logs: None,
      meta: None,
      status: None,
      user_id: None,
      organisation_id: None
    }
  }

  pub fn set_id(&mut self, id: i32) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i32) -> Grader {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i32> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_created(&mut self, created: String) {
    self.created = Some(created);
  }

  pub fn with_created(mut self, created: String) -> Grader {
    self.created = Some(created);
    self
  }

  pub fn created(&self) -> Option<&String> {
    self.created.as_ref()
  }

  pub fn reset_created(&mut self) {
    self.created = None;
  }

  pub fn set_updated(&mut self, updated: String) {
    self.updated = Some(updated);
  }

  pub fn with_updated(mut self, updated: String) -> Grader {
    self.updated = Some(updated);
    self
  }

  pub fn updated(&self) -> Option<&String> {
    self.updated.as_ref()
  }

  pub fn reset_updated(&mut self) {
    self.updated = None;
  }

  pub fn set_dataset_url(&mut self, dataset_url: String) {
    self.dataset_url = Some(dataset_url);
  }

  pub fn with_dataset_url(mut self, dataset_url: String) -> Grader {
    self.dataset_url = Some(dataset_url);
    self
  }

  pub fn dataset_url(&self) -> Option<&String> {
    self.dataset_url.as_ref()
  }

  pub fn reset_dataset_url(&mut self) {
    self.dataset_url = None;
  }

  pub fn set_code_access_mode(&mut self, code_access_mode: String) {
    self.code_access_mode = code_access_mode;
  }

  pub fn with_code_access_mode(mut self, code_access_mode: String) -> Grader {
    self.code_access_mode = code_access_mode;
    self
  }

  pub fn code_access_mode(&self) -> &String {
    &self.code_access_mode
  }


  pub fn set_cluster_id(&mut self, cluster_id: i32) {
    self.cluster_id = Some(cluster_id);
  }

  pub fn with_cluster_id(mut self, cluster_id: i32) -> Grader {
    self.cluster_id = Some(cluster_id);
    self
  }

  pub fn cluster_id(&self) -> Option<&i32> {
    self.cluster_id.as_ref()
  }

  pub fn reset_cluster_id(&mut self) {
    self.cluster_id = None;
  }

  pub fn set_docker_username(&mut self, docker_username: String) {
    self.docker_username = docker_username;
  }

  pub fn with_docker_username(mut self, docker_username: String) -> Grader {
    self.docker_username = docker_username;
    self
  }

  pub fn docker_username(&self) -> &String {
    &self.docker_username
  }


  pub fn set_docker_password(&mut self, docker_password: String) {
    self.docker_password = docker_password;
  }

  pub fn with_docker_password(mut self, docker_password: String) -> Grader {
    self.docker_password = docker_password;
    self
  }

  pub fn docker_password(&self) -> &String {
    &self.docker_password
  }


  pub fn set_docker_registry(&mut self, docker_registry: String) {
    self.docker_registry = Some(docker_registry);
  }

  pub fn with_docker_registry(mut self, docker_registry: String) -> Grader {
    self.docker_registry = Some(docker_registry);
    self
  }

  pub fn docker_registry(&self) -> Option<&String> {
    self.docker_registry.as_ref()
  }

  pub fn reset_docker_registry(&mut self) {
    self.docker_registry = None;
  }

  pub fn set_workflow_spec(&mut self, workflow_spec: Value) {
    self.workflow_spec = Some(workflow_spec);
  }

  pub fn with_workflow_spec(mut self, workflow_spec: Value) -> Grader {
    self.workflow_spec = Some(workflow_spec);
    self
  }

  pub fn workflow_spec(&self) -> Option<&Value> {
    self.workflow_spec.as_ref()
  }

  pub fn reset_workflow_spec(&mut self) {
    self.workflow_spec = None;
  }

  pub fn set_evaluation_code(&mut self, evaluation_code: String) {
    self.evaluation_code = evaluation_code;
  }

  pub fn with_evaluation_code(mut self, evaluation_code: String) -> Grader {
    self.evaluation_code = evaluation_code;
    self
  }

  pub fn evaluation_code(&self) -> &String {
    &self.evaluation_code
  }


  pub fn set_storage_capacity(&mut self, storage_capacity: String) {
    self.storage_capacity = Some(storage_capacity);
  }

  pub fn with_storage_capacity(mut self, storage_capacity: String) -> Grader {
    self.storage_capacity = Some(storage_capacity);
    self
  }

  pub fn storage_capacity(&self) -> Option<&String> {
    self.storage_capacity.as_ref()
  }

  pub fn reset_storage_capacity(&mut self) {
    self.storage_capacity = None;
  }

  pub fn set_logs(&mut self, logs: Value) {
    self.logs = Some(logs);
  }

  pub fn with_logs(mut self, logs: Value) -> Grader {
    self.logs = Some(logs);
    self
  }

  pub fn logs(&self) -> Option<&Value> {
    self.logs.as_ref()
  }

  pub fn reset_logs(&mut self) {
    self.logs = None;
  }

  pub fn set_meta(&mut self, meta: Value) {
    self.meta = Some(meta);
  }

  pub fn with_meta(mut self, meta: Value) -> Grader {
    self.meta = Some(meta);
    self
  }

  pub fn meta(&self) -> Option<&Value> {
    self.meta.as_ref()
  }

  pub fn reset_meta(&mut self) {
    self.meta = None;
  }

  pub fn set_status(&mut self, status: bool) {
    self.status = Some(status);
  }

  pub fn with_status(mut self, status: bool) -> Grader {
    self.status = Some(status);
    self
  }

  pub fn status(&self) -> Option<&bool> {
    self.status.as_ref()
  }

  pub fn reset_status(&mut self) {
    self.status = None;
  }

  pub fn set_user_id(&mut self, user_id: i32) {
    self.user_id = Some(user_id);
  }

  pub fn with_user_id(mut self, user_id: i32) -> Grader {
    self.user_id = Some(user_id);
    self
  }

  pub fn user_id(&self) -> Option<&i32> {
    self.user_id.as_ref()
  }

  pub fn reset_user_id(&mut self) {
    self.user_id = None;
  }

  pub fn set_organisation_id(&mut self, organisation_id: i32) {
    self.organisation_id = Some(organisation_id);
  }

  pub fn with_organisation_id(mut self, organisation_id: i32) -> Grader {
    self.organisation_id = Some(organisation_id);
    self
  }

  pub fn organisation_id(&self) -> Option<&i32> {
    self.organisation_id.as_ref()
  }

  pub fn reset_organisation_id(&mut self) {
    self.organisation_id = None;
  }

}



