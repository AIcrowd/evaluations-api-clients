/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Evaluations API
 * API to create and evaluate custom challenges
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AuthLogout
 */
export interface AuthLogout {
    /**
     * Logout message
     * @type {string}
     * @memberof AuthLogout
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * Authorization token that should be used in the headers
     * @type {string}
     * @memberof AuthResponse
     */
    authorization?: string;
}

/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * ID
     * @type {number}
     * @memberof Cluster
     */
    id?: number;
    /**
     * Creation time
     * @type {Date}
     * @memberof Cluster
     */
    created?: Date;
    /**
     * Last updation time
     * @type {Date}
     * @memberof Cluster
     */
    updated?: Date;
    /**
     * Remote address used to connect to the cluster
     * @type {string}
     * @memberof Cluster
     */
    remoteAddress: string;
    /**
     * Authentication needed for the cluster
     * @type {string}
     * @memberof Cluster
     */
    authToken: string;
    /**
     * Docker registry username
     * @type {string}
     * @memberof Cluster
     */
    dockerUsername: string;
    /**
     * Docker registry password
     * @type {string}
     * @memberof Cluster
     */
    dockerPassword: string;
    /**
     * Docker registry URL. Dockerhub is used by default.
     * @type {string}
     * @memberof Cluster
     */
    dockerRegistry?: string;
    /**
     * Storage class to use for datasets
     * @type {string}
     * @memberof Cluster
     */
    storageClass?: string;
    /**
     * Readiness of the cluster
     * @type {boolean}
     * @memberof Cluster
     */
    status?: boolean;
    /**
     * Additional metadata
     * @type {any}
     * @memberof Cluster
     */
    meta?: any;
    /**
     * User ID
     * @type {number}
     * @memberof Cluster
     */
    userId?: number;
    /**
     * Organisation ID
     * @type {number}
     * @memberof Cluster
     */
    organisationId?: number;
}

/**
 * 
 * @export
 * @interface GenericFeedback
 */
export interface GenericFeedback {
    /**
     * Status of the operation
     * @type {boolean}
     * @memberof GenericFeedback
     */
    status: boolean;
    /**
     * Additional metadata to add
     * @type {any}
     * @memberof GenericFeedback
     */
    meta?: any;
}

/**
 * 
 * @export
 * @interface Grader
 */
export interface Grader {
    /**
     * ID
     * @type {number}
     * @memberof Grader
     */
    id?: number;
    /**
     * Creation time
     * @type {Date}
     * @memberof Grader
     */
    created?: Date;
    /**
     * Last updation time
     * @type {Date}
     * @memberof Grader
     */
    updated?: Date;
    /**
     * S3 link of the Dataset
     * @type {string}
     * @memberof Grader
     */
    datasetUrl?: string;
    /**
     * Cluster to run the grader on
     * @type {number}
     * @memberof Grader
     */
    clusterId?: number;
    /**
     * Argo workflow template spec
     * @type {any}
     * @memberof Grader
     */
    workflowSpec?: any;
    /**
     * Git URL of the repository containing the code that will be used for the evaluation
     * @type {string}
     * @memberof Grader
     */
    evaluatorRepo: string;
    /**
     * Git branch/tag that should be used with the evaluator repository.
     * @type {string}
     * @memberof Grader
     */
    evaluatorRepoTag?: string;
    /**
     * Size of the dataset partition to request. Please provide at least 2x of the size of the dataset.
     * @type {string}
     * @memberof Grader
     */
    storageCapacity?: string;
    /**
     * Logs from argo workflow
     * @type {any}
     * @memberof Grader
     */
    logs?: any;
    /**
     * Additional meta data of the grader
     * @type {any}
     * @memberof Grader
     */
    meta?: any;
    /**
     * Status of the grader - True if it ready, False otherwise
     * @type {string}
     * @memberof Grader
     */
    status?: string;
    /**
     * User ID
     * @type {number}
     * @memberof Grader
     */
    userId?: number;
    /**
     * Organisation ID
     * @type {number}
     * @memberof Grader
     */
    organisationId?: number;
}

/**
 * 
 * @export
 * @interface GraderFeedback
 */
export interface GraderFeedback {
    /**
     * Status of the grader
     * @type {boolean}
     * @memberof GraderFeedback
     */
    status: boolean;
    /**
     * Serialized YAML workflow spec
     * @type {string}
     * @memberof GraderFeedback
     */
    workflowSpec: string;
}

/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * The email address
     * @type {string}
     * @memberof Login
     */
    email: string;
    /**
     * The user password 
     * @type {string}
     * @memberof Login
     */
    password: string;
}

/**
 * 
 * @export
 * @interface Organisation
 */
export interface Organisation {
    /**
     * ID
     * @type {number}
     * @memberof Organisation
     */
    id?: number;
    /**
     * Organisation Name
     * @type {string}
     * @memberof Organisation
     */
    name: string;
    /**
     * Point of contact email
     * @type {string}
     * @memberof Organisation
     */
    pocEmail: string;
    /**
     * Creation Time
     * @type {Date}
     * @memberof Organisation
     */
    createdOn?: Date;
    /**
     * Total assigned evaluation quota
     * @type {number}
     * @memberof Organisation
     */
    totalQuota?: number;
    /**
     * Available evaluation quota
     * @type {number}
     * @memberof Organisation
     */
    quota?: number;
}

/**
 * 
 * @export
 * @interface OrganisationQuota
 */
export interface OrganisationQuota {
    /**
     * Quota to be added or reduced
     * @type {number}
     * @memberof OrganisationQuota
     */
    quota: number;
}

/**
 * 
 * @export
 * @interface SubmissionFeedback
 */
export interface SubmissionFeedback {
    /**
     * Status of the submission
     * @type {string}
     * @memberof SubmissionFeedback
     */
    status: string;
    /**
     * S3 link of the outputs
     * @type {string}
     * @memberof SubmissionFeedback
     */
    outputs: string;
    /**
     * Additional outputs
     * @type {number}
     * @memberof SubmissionFeedback
     */
    score: number;
    /**
     * Output on stdout for run-evaluator.run-submitted-code step
     * @type {string}
     * @memberof SubmissionFeedback
     */
    logs: string;
}

/**
 * 
 * @export
 * @interface Submissions
 */
export interface Submissions {
    /**
     * ID
     * @type {number}
     * @memberof Submissions
     */
    id?: number;
    /**
     * Creation time
     * @type {Date}
     * @memberof Submissions
     */
    created?: Date;
    /**
     * Last updation time
     * @type {Date}
     * @memberof Submissions
     */
    updated?: Date;
    /**
     * Participant identifier
     * @type {number}
     * @memberof Submissions
     */
    participantId?: number;
    /**
     * Round identifier
     * @type {number}
     * @memberof Submissions
     */
    roundId?: number;
    /**
     * Grader identifier
     * @type {number}
     * @memberof Submissions
     */
    graderId: number;
    /**
     * URL to the submission code
     * @type {any}
     * @memberof Submissions
     */
    submissionData?: any;
    /**
     * Current status of the submission
     * @type {string}
     * @memberof Submissions
     */
    status?: string;
    /**
     * S3 link of the output (available after the evaluation)
     * @type {string}
     * @memberof Submissions
     */
    output?: string;
    /**
     * Array of any additional outputs
     * @type {any}
     * @memberof Submissions
     */
    additionalOutputs?: any;
    /**
     * S3 link of the STDOUT of the evaluation
     * @type {any}
     * @memberof Submissions
     */
    logs?: any;
    /**
     * Evaluation start time
     * @type {Date}
     * @memberof Submissions
     */
    started?: Date;
    /**
     * Evaluation end time
     * @type {Date}
     * @memberof Submissions
     */
    ended?: Date;
    /**
     * Additional meta-data
     * @type {any}
     * @memberof Submissions
     */
    meta?: any;
    /**
     * User ID
     * @type {number}
     * @memberof Submissions
     */
    userId?: number;
    /**
     * Organisation ID
     * @type {number}
     * @memberof Submissions
     */
    organisationId?: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * ID
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * Email
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * Admin Boolean
     * @type {boolean}
     * @memberof User
     */
    admin?: boolean;
    /**
     * Creation Time
     * @type {Date}
     * @memberof User
     */
    createdOn?: Date;
    /**
     * Hashed Password
     * @type {string}
     * @memberof User
     */
    passwordHash?: string;
    /**
     * Total assigned evaluation quota
     * @type {number}
     * @memberof User
     */
    totalQuota?: number;
    /**
     * Available evaluation quota
     * @type {number}
     * @memberof User
     */
    quota?: number;
    /**
     * Organisation identifier
     * @type {number}
     * @memberof User
     */
    organisationId: number;
    /**
     * user password
     * @type {string}
     * @memberof User
     */
    password: string;
}

/**
 * 
 * @export
 * @interface UserQuota
 */
export interface UserQuota {
    /**
     * Quota to be added or reduced
     * @type {number}
     * @memberof UserQuota
     */
    quota: number;
}


/**
 * ArgoApi - fetch parameter creator
 * @export
 */
export const ArgoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update the status of an object
         * @param {string} modelName 
         * @param {number} objectId 
         * @param {GenericFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGenericFeedbackContract(modelName: string, objectId: number, payload: GenericFeedback, options: any = {}): FetchArgs {
            // verify required parameter 'modelName' is not null or undefined
            if (modelName === null || modelName === undefined) {
                throw new RequiredError('modelName','Required parameter modelName was null or undefined when calling postGenericFeedbackContract.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId','Required parameter objectId was null or undefined when calling postGenericFeedbackContract.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postGenericFeedbackContract.');
            }
            const localVarPath = `/argo/{model_name}/{object_id}`
                .replace(`{${"model_name"}}`, encodeURIComponent(String(modelName)))
                .replace(`{${"object_id"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GenericFeedback" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the grader details
         * @param {number} graderId 
         * @param {GraderFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraderFeedbackDao(graderId: number, payload: GraderFeedback, options: any = {}): FetchArgs {
            // verify required parameter 'graderId' is not null or undefined
            if (graderId === null || graderId === undefined) {
                throw new RequiredError('graderId','Required parameter graderId was null or undefined when calling postGraderFeedbackDao.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postGraderFeedbackDao.');
            }
            const localVarPath = `/argo/graders/{grader_id}`
                .replace(`{${"grader_id"}}`, encodeURIComponent(String(graderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GraderFeedback" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the submission details
         * @param {number} submissionId 
         * @param {SubmissionFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmissionFeedbackDao(submissionId: number, payload: SubmissionFeedback, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling postSubmissionFeedbackDao.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postSubmissionFeedbackDao.');
            }
            const localVarPath = `/argo/submissions/{submission_id}`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SubmissionFeedback" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArgoApi - functional programming interface
 * @export
 */
export const ArgoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Update the status of an object
         * @param {string} modelName 
         * @param {number} objectId 
         * @param {GenericFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGenericFeedbackContract(modelName: string, objectId: number, payload: GenericFeedback, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArgoApiFetchParamCreator(configuration).postGenericFeedbackContract(modelName, objectId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the grader details
         * @param {number} graderId 
         * @param {GraderFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraderFeedbackDao(graderId: number, payload: GraderFeedback, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArgoApiFetchParamCreator(configuration).postGraderFeedbackDao(graderId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the submission details
         * @param {number} submissionId 
         * @param {SubmissionFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmissionFeedbackDao(submissionId: number, payload: SubmissionFeedback, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ArgoApiFetchParamCreator(configuration).postSubmissionFeedbackDao(submissionId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ArgoApi - factory interface
 * @export
 */
export const ArgoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Update the status of an object
         * @param {string} modelName 
         * @param {number} objectId 
         * @param {GenericFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGenericFeedbackContract(modelName: string, objectId: number, payload: GenericFeedback, options?: any) {
            return ArgoApiFp(configuration).postGenericFeedbackContract(modelName, objectId, payload, options)(fetch, basePath);
        },
        /**
         * Update the grader details
         * @param {number} graderId 
         * @param {GraderFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraderFeedbackDao(graderId: number, payload: GraderFeedback, options?: any) {
            return ArgoApiFp(configuration).postGraderFeedbackDao(graderId, payload, options)(fetch, basePath);
        },
        /**
         * Update the submission details
         * @param {number} submissionId 
         * @param {SubmissionFeedback} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmissionFeedbackDao(submissionId: number, payload: SubmissionFeedback, options?: any) {
            return ArgoApiFp(configuration).postSubmissionFeedbackDao(submissionId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * ArgoApi - object-oriented interface
 * @export
 * @class ArgoApi
 * @extends {BaseAPI}
 */
export class ArgoApi extends BaseAPI {
    /**
     * Update the status of an object
     * @param {string} modelName 
     * @param {number} objectId 
     * @param {GenericFeedback} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArgoApi
     */
    public postGenericFeedbackContract(modelName: string, objectId: number, payload: GenericFeedback, options?: any) {
        return ArgoApiFp(this.configuration).postGenericFeedbackContract(modelName, objectId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Update the grader details
     * @param {number} graderId 
     * @param {GraderFeedback} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArgoApi
     */
    public postGraderFeedbackDao(graderId: number, payload: GraderFeedback, options?: any) {
        return ArgoApiFp(this.configuration).postGraderFeedbackDao(graderId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Update the submission details
     * @param {number} submissionId 
     * @param {SubmissionFeedback} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArgoApi
     */
    public postSubmissionFeedbackDao(submissionId: number, payload: SubmissionFeedback, options?: any) {
        return ArgoApiFp(this.configuration).postSubmissionFeedbackDao(submissionId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Logout a user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogoutApi(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User login
         * @param {Login} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserLogin(payload: Login, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postUserLogin.');
            }
            const localVarPath = `/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Login" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Logout a user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogoutApi(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthLogout> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).postLogoutApi(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * User login
         * @param {Login} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserLogin(payload: Login, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthResponse> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).postUserLogin(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Logout a user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLogoutApi(xFields?: string, options?: any) {
            return AuthApiFp(configuration).postLogoutApi(xFields, options)(fetch, basePath);
        },
        /**
         * User login
         * @param {Login} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserLogin(payload: Login, xFields?: string, options?: any) {
            return AuthApiFp(configuration).postUserLogin(payload, xFields, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Logout a user
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postLogoutApi(xFields?: string, options?: any) {
        return AuthApiFp(this.configuration).postLogoutApi(xFields, options)(this.fetch, this.basePath);
    }

    /**
     * User login
     * @param {Login} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postUserLogin(payload: Login, xFields?: string, options?: any) {
        return AuthApiFp(this.configuration).postUserLogin(payload, xFields, options)(this.fetch, this.basePath);
    }

}

/**
 * ClustersApi - fetch parameter creator
 * @export
 */
export const ClustersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterDao(clusterId: number, options: any = {}): FetchArgs {
            // verify required parameter 'clusterId' is not null or undefined
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling deleteClusterDao.');
            }
            const localVarPath = `/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information of a cluster
         * @param {number} clusterId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterDao(clusterId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'clusterId' is not null or undefined
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling getClusterDao.');
            }
            const localVarPath = `/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all clusters
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterListDao(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clusters/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new cluster
         * @param {Cluster} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postClusterListDao(payload: Cluster, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postClusterListDao.');
            }
            const localVarPath = `/clusters/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cluster" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterDao(clusterId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).deleteClusterDao(clusterId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information of a cluster
         * @param {number} clusterId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterDao(clusterId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cluster> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getClusterDao(clusterId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all clusters
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterListDao(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cluster>> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getClusterListDao(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add a new cluster
         * @param {Cluster} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postClusterListDao(payload: Cluster, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cluster> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).postClusterListDao(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a cluster
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClusterDao(clusterId: number, options?: any) {
            return ClustersApiFp(configuration).deleteClusterDao(clusterId, options)(fetch, basePath);
        },
        /**
         * Get information of a cluster
         * @param {number} clusterId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterDao(clusterId: number, xFields?: string, options?: any) {
            return ClustersApiFp(configuration).getClusterDao(clusterId, xFields, options)(fetch, basePath);
        },
        /**
         * Get all clusters
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClusterListDao(xFields?: string, options?: any) {
            return ClustersApiFp(configuration).getClusterListDao(xFields, options)(fetch, basePath);
        },
        /**
         * Add a new cluster
         * @param {Cluster} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postClusterListDao(payload: Cluster, xFields?: string, options?: any) {
            return ClustersApiFp(configuration).postClusterListDao(payload, xFields, options)(fetch, basePath);
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * Delete a cluster
     * @param {number} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteClusterDao(clusterId: number, options?: any) {
        return ClustersApiFp(this.configuration).deleteClusterDao(clusterId, options)(this.fetch, this.basePath);
    }

    /**
     * Get information of a cluster
     * @param {number} clusterId 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterDao(clusterId: number, xFields?: string, options?: any) {
        return ClustersApiFp(this.configuration).getClusterDao(clusterId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Get all clusters
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getClusterListDao(xFields?: string, options?: any) {
        return ClustersApiFp(this.configuration).getClusterListDao(xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Add a new cluster
     * @param {Cluster} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public postClusterListDao(payload: Cluster, xFields?: string, options?: any) {
        return ClustersApiFp(this.configuration).postClusterListDao(payload, xFields, options)(this.fetch, this.basePath);
    }

}

/**
 * GradersApi - fetch parameter creator
 * @export
 */
export const GradersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a grader
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraderDao(graderId: number, options: any = {}): FetchArgs {
            // verify required parameter 'graderId' is not null or undefined
            if (graderId === null || graderId === undefined) {
                throw new RequiredError('graderId','Required parameter graderId was null or undefined when calling deleteGraderDao.');
            }
            const localVarPath = `/graders/{grader_id}`
                .replace(`{${"grader_id"}}`, encodeURIComponent(String(graderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information of a grader
         * @param {number} graderId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderDao(graderId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'graderId' is not null or undefined
            if (graderId === null || graderId === undefined) {
                throw new RequiredError('graderId','Required parameter graderId was null or undefined when calling getGraderDao.');
            }
            const localVarPath = `/graders/{grader_id}`
                .replace(`{${"grader_id"}}`, encodeURIComponent(String(graderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all grader
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderListDao(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/graders/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new grader
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraderListDao(payload: Grader, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postGraderListDao.');
            }
            const localVarPath = `/graders/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Grader" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a grader
         * @param {number} graderId 
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGraderDao(graderId: number, payload: Grader, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'graderId' is not null or undefined
            if (graderId === null || graderId === undefined) {
                throw new RequiredError('graderId','Required parameter graderId was null or undefined when calling putGraderDao.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling putGraderDao.');
            }
            const localVarPath = `/graders/{grader_id}`
                .replace(`{${"grader_id"}}`, encodeURIComponent(String(graderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Grader" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GradersApi - functional programming interface
 * @export
 */
export const GradersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a grader
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraderDao(graderId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).deleteGraderDao(graderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information of a grader
         * @param {number} graderId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderDao(graderId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Grader> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).getGraderDao(graderId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all grader
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderListDao(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Grader>> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).getGraderListDao(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new grader
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraderListDao(payload: Grader, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Grader> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).postGraderListDao(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a grader
         * @param {number} graderId 
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGraderDao(graderId: number, payload: Grader, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Grader> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).putGraderDao(graderId, payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GradersApi - factory interface
 * @export
 */
export const GradersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a grader
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGraderDao(graderId: number, options?: any) {
            return GradersApiFp(configuration).deleteGraderDao(graderId, options)(fetch, basePath);
        },
        /**
         * Get information of a grader
         * @param {number} graderId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderDao(graderId: number, xFields?: string, options?: any) {
            return GradersApiFp(configuration).getGraderDao(graderId, xFields, options)(fetch, basePath);
        },
        /**
         * Get all grader
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderListDao(xFields?: string, options?: any) {
            return GradersApiFp(configuration).getGraderListDao(xFields, options)(fetch, basePath);
        },
        /**
         * Create a new grader
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGraderListDao(payload: Grader, xFields?: string, options?: any) {
            return GradersApiFp(configuration).postGraderListDao(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Update a grader
         * @param {number} graderId 
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putGraderDao(graderId: number, payload: Grader, xFields?: string, options?: any) {
            return GradersApiFp(configuration).putGraderDao(graderId, payload, xFields, options)(fetch, basePath);
        },
    };
};

/**
 * GradersApi - object-oriented interface
 * @export
 * @class GradersApi
 * @extends {BaseAPI}
 */
export class GradersApi extends BaseAPI {
    /**
     * Delete a grader
     * @param {number} graderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public deleteGraderDao(graderId: number, options?: any) {
        return GradersApiFp(this.configuration).deleteGraderDao(graderId, options)(this.fetch, this.basePath);
    }

    /**
     * Get information of a grader
     * @param {number} graderId 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public getGraderDao(graderId: number, xFields?: string, options?: any) {
        return GradersApiFp(this.configuration).getGraderDao(graderId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Get all grader
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public getGraderListDao(xFields?: string, options?: any) {
        return GradersApiFp(this.configuration).getGraderListDao(xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new grader
     * @param {Grader} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public postGraderListDao(payload: Grader, xFields?: string, options?: any) {
        return GradersApiFp(this.configuration).postGraderListDao(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Update a grader
     * @param {number} graderId 
     * @param {Grader} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public putGraderDao(graderId: number, payload: Grader, xFields?: string, options?: any) {
        return GradersApiFp(this.configuration).putGraderDao(graderId, payload, xFields, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganisationsApi - fetch parameter creator
 * @export
 */
export const OrganisationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an Organisation
         * @param {number} organisationId Organisation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganisationDao(organisationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling deleteOrganisationDao.');
            }
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information of an organisation
         * @param {number} organisationId Organisation identifier
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationDao(organisationId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling getOrganisationDao.');
            }
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all organisations
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationListDao(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/organisations/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new organisation
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganisationListDao(payload: Organisation, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postOrganisationListDao.');
            }
            const localVarPath = `/organisations/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organisation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Organisation
         * @param {number} organisationId Organisation identifier
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrganisationDao(organisationId: number, payload: Organisation, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling putOrganisationDao.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling putOrganisationDao.');
            }
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organisation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or subtract quota for an organisation
         * @param {number} organisationId Organisation identifier
         * @param {OrganisationQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQuotaDao(organisationId: number, payload: OrganisationQuota, options: any = {}): FetchArgs {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling putQuotaDao.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling putQuotaDao.');
            }
            const localVarPath = `/organisations/addquota/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganisationQuota" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationsApi - functional programming interface
 * @export
 */
export const OrganisationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete an Organisation
         * @param {number} organisationId Organisation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganisationDao(organisationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).deleteOrganisationDao(organisationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information of an organisation
         * @param {number} organisationId Organisation identifier
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationDao(organisationId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organisation> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).getOrganisationDao(organisationId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all organisations
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationListDao(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Organisation>> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).getOrganisationListDao(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new organisation
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganisationListDao(payload: Organisation, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organisation> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).postOrganisationListDao(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an Organisation
         * @param {number} organisationId Organisation identifier
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrganisationDao(organisationId: number, payload: Organisation, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organisation> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).putOrganisationDao(organisationId, payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add or subtract quota for an organisation
         * @param {number} organisationId Organisation identifier
         * @param {OrganisationQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQuotaDao(organisationId: number, payload: OrganisationQuota, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).putQuotaDao(organisationId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganisationsApi - factory interface
 * @export
 */
export const OrganisationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete an Organisation
         * @param {number} organisationId Organisation identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganisationDao(organisationId: number, options?: any) {
            return OrganisationsApiFp(configuration).deleteOrganisationDao(organisationId, options)(fetch, basePath);
        },
        /**
         * Get information of an organisation
         * @param {number} organisationId Organisation identifier
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationDao(organisationId: number, xFields?: string, options?: any) {
            return OrganisationsApiFp(configuration).getOrganisationDao(organisationId, xFields, options)(fetch, basePath);
        },
        /**
         * Get all organisations
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisationListDao(xFields?: string, options?: any) {
            return OrganisationsApiFp(configuration).getOrganisationListDao(xFields, options)(fetch, basePath);
        },
        /**
         * Create a new organisation
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrganisationListDao(payload: Organisation, xFields?: string, options?: any) {
            return OrganisationsApiFp(configuration).postOrganisationListDao(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Update an Organisation
         * @param {number} organisationId Organisation identifier
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrganisationDao(organisationId: number, payload: Organisation, xFields?: string, options?: any) {
            return OrganisationsApiFp(configuration).putOrganisationDao(organisationId, payload, xFields, options)(fetch, basePath);
        },
        /**
         * Add or subtract quota for an organisation
         * @param {number} organisationId Organisation identifier
         * @param {OrganisationQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQuotaDao(organisationId: number, payload: OrganisationQuota, options?: any) {
            return OrganisationsApiFp(configuration).putQuotaDao(organisationId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * OrganisationsApi - object-oriented interface
 * @export
 * @class OrganisationsApi
 * @extends {BaseAPI}
 */
export class OrganisationsApi extends BaseAPI {
    /**
     * Delete an Organisation
     * @param {number} organisationId Organisation identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public deleteOrganisationDao(organisationId: number, options?: any) {
        return OrganisationsApiFp(this.configuration).deleteOrganisationDao(organisationId, options)(this.fetch, this.basePath);
    }

    /**
     * Get information of an organisation
     * @param {number} organisationId Organisation identifier
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public getOrganisationDao(organisationId: number, xFields?: string, options?: any) {
        return OrganisationsApiFp(this.configuration).getOrganisationDao(organisationId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Get all organisations
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public getOrganisationListDao(xFields?: string, options?: any) {
        return OrganisationsApiFp(this.configuration).getOrganisationListDao(xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new organisation
     * @param {Organisation} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public postOrganisationListDao(payload: Organisation, xFields?: string, options?: any) {
        return OrganisationsApiFp(this.configuration).postOrganisationListDao(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Update an Organisation
     * @param {number} organisationId Organisation identifier
     * @param {Organisation} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public putOrganisationDao(organisationId: number, payload: Organisation, xFields?: string, options?: any) {
        return OrganisationsApiFp(this.configuration).putOrganisationDao(organisationId, payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Add or subtract quota for an organisation
     * @param {number} organisationId Organisation identifier
     * @param {OrganisationQuota} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public putQuotaDao(organisationId: number, payload: OrganisationQuota, options?: any) {
        return OrganisationsApiFp(this.configuration).putQuotaDao(organisationId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * SubmissionsApi - fetch parameter creator
 * @export
 */
export const SubmissionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Stop evaluation of a submission
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmissionDao(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling deleteSubmissionDao.');
            }
            const localVarPath = `/submissions/{submission_id}`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a submission
         * @param {number} submissionId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionDao(submissionId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling getSubmissionDao.');
            }
            const localVarPath = `/submissions/{submission_id}`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the submission data
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionDataDao(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling getSubmissionDataDao.');
            }
            const localVarPath = `/submissions/{submission_id}/data`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all submissions
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionListDao(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submissions/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a new submission
         * @param {Submissions} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmissionListDao(payload: Submissions, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postSubmissionListDao.');
            }
            const localVarPath = `/submissions/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submissions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionsApi - functional programming interface
 * @export
 */
export const SubmissionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Stop evaluation of a submission
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmissionDao(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).deleteSubmissionDao(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details of a submission
         * @param {number} submissionId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionDao(submissionId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).getSubmissionDao(submissionId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the submission data
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionDataDao(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).getSubmissionDataDao(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all submissions
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionListDao(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Submissions>> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).getSubmissionListDao(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Make a new submission
         * @param {Submissions} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmissionListDao(payload: Submissions, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).postSubmissionListDao(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmissionsApi - factory interface
 * @export
 */
export const SubmissionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Stop evaluation of a submission
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmissionDao(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).deleteSubmissionDao(submissionId, options)(fetch, basePath);
        },
        /**
         * Get details of a submission
         * @param {number} submissionId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionDao(submissionId: number, xFields?: string, options?: any) {
            return SubmissionsApiFp(configuration).getSubmissionDao(submissionId, xFields, options)(fetch, basePath);
        },
        /**
         * Get the submission data
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionDataDao(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).getSubmissionDataDao(submissionId, options)(fetch, basePath);
        },
        /**
         * Get all submissions
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionListDao(xFields?: string, options?: any) {
            return SubmissionsApiFp(configuration).getSubmissionListDao(xFields, options)(fetch, basePath);
        },
        /**
         * Make a new submission
         * @param {Submissions} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubmissionListDao(payload: Submissions, xFields?: string, options?: any) {
            return SubmissionsApiFp(configuration).postSubmissionListDao(payload, xFields, options)(fetch, basePath);
        },
    };
};

/**
 * SubmissionsApi - object-oriented interface
 * @export
 * @class SubmissionsApi
 * @extends {BaseAPI}
 */
export class SubmissionsApi extends BaseAPI {
    /**
     * Stop evaluation of a submission
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public deleteSubmissionDao(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).deleteSubmissionDao(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get details of a submission
     * @param {number} submissionId 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public getSubmissionDao(submissionId: number, xFields?: string, options?: any) {
        return SubmissionsApiFp(this.configuration).getSubmissionDao(submissionId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Get the submission data
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public getSubmissionDataDao(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).getSubmissionDataDao(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get all submissions
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public getSubmissionListDao(xFields?: string, options?: any) {
        return SubmissionsApiFp(this.configuration).getSubmissionListDao(xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Make a new submission
     * @param {Submissions} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public postSubmissionListDao(payload: Submissions, xFields?: string, options?: any) {
        return SubmissionsApiFp(this.configuration).postSubmissionListDao(payload, xFields, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a user
         * @param {number} userId User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDao(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserDao.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information of a user
         * @param {number} userId User identifier
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDao(userId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserDao.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserListDao(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserListDao(payload: User, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling postUserListDao.');
            }
            const localVarPath = `/users/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or subtract quota for a user
         * @param {number} userId User identifier
         * @param {UserQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQuotaDao(userId: number, payload: UserQuota, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling putQuotaDao.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling putQuotaDao.');
            }
            const localVarPath = `/users/addquota/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserQuota" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user
         * @param {number} userId User identifier
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserDao(userId: number, payload: User, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling putUserDao.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling putUserDao.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a user
         * @param {number} userId User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDao(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUserDao(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information of a user
         * @param {number} userId User identifier
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDao(userId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserDao(userId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserListDao(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserListDao(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new user
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserListDao(payload: User, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).postUserListDao(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add or subtract quota for a user
         * @param {number} userId User identifier
         * @param {UserQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQuotaDao(userId: number, payload: UserQuota, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).putQuotaDao(userId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a user
         * @param {number} userId User identifier
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserDao(userId: number, payload: User, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).putUserDao(userId, payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a user
         * @param {number} userId User identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDao(userId: number, options?: any) {
            return UsersApiFp(configuration).deleteUserDao(userId, options)(fetch, basePath);
        },
        /**
         * Get information of a user
         * @param {number} userId User identifier
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDao(userId: number, xFields?: string, options?: any) {
            return UsersApiFp(configuration).getUserDao(userId, xFields, options)(fetch, basePath);
        },
        /**
         * Get all user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserListDao(xFields?: string, options?: any) {
            return UsersApiFp(configuration).getUserListDao(xFields, options)(fetch, basePath);
        },
        /**
         * Create a new user
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserListDao(payload: User, xFields?: string, options?: any) {
            return UsersApiFp(configuration).postUserListDao(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Add or subtract quota for a user
         * @param {number} userId User identifier
         * @param {UserQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putQuotaDao(userId: number, payload: UserQuota, options?: any) {
            return UsersApiFp(configuration).putQuotaDao(userId, payload, options)(fetch, basePath);
        },
        /**
         * Update a user
         * @param {number} userId User identifier
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUserDao(userId: number, payload: User, xFields?: string, options?: any) {
            return UsersApiFp(configuration).putUserDao(userId, payload, xFields, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Delete a user
     * @param {number} userId User identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserDao(userId: number, options?: any) {
        return UsersApiFp(this.configuration).deleteUserDao(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Get information of a user
     * @param {number} userId User identifier
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserDao(userId: number, xFields?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserDao(userId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Get all user
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserListDao(xFields?: string, options?: any) {
        return UsersApiFp(this.configuration).getUserListDao(xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new user
     * @param {User} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUserListDao(payload: User, xFields?: string, options?: any) {
        return UsersApiFp(this.configuration).postUserListDao(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Add or subtract quota for a user
     * @param {number} userId User identifier
     * @param {UserQuota} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putQuotaDao(userId: number, payload: UserQuota, options?: any) {
        return UsersApiFp(this.configuration).putQuotaDao(userId, payload, options)(this.fetch, this.basePath);
    }

    /**
     * Update a user
     * @param {number} userId User identifier
     * @param {User} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUserDao(userId: number, payload: User, xFields?: string, options?: any) {
        return UsersApiFp(this.configuration).putUserDao(userId, payload, xFields, options)(this.fetch, this.basePath);
    }

}

