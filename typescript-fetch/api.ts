/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * AIcrowd Evaluations API
 * API to create and evaluate custom challenges on AIcrowd!
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://localhost/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AuthLogout
 */
export interface AuthLogout {
    /**
     * Logout message
     * @type {string}
     * @memberof AuthLogout
     */
    message?: string;
}

/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * API Authorization token that should be used in the headers
     * @type {string}
     * @memberof AuthResponse
     */
    authorization?: string;
}

/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * ID
     * @type {number}
     * @memberof Cluster
     */
    id?: number;
    /**
     * Creation time
     * @type {Date}
     * @memberof Cluster
     */
    created?: Date;
    /**
     * Last updation time
     * @type {Date}
     * @memberof Cluster
     */
    updated?: Date;
    /**
     * Remote address used to connect to the cluster
     * @type {string}
     * @memberof Cluster
     */
    remoteAddress: string;
    /**
     * Authentication needed for the cluster
     * @type {string}
     * @memberof Cluster
     */
    authToken: string;
    /**
     * Docker registry username
     * @type {string}
     * @memberof Cluster
     */
    dockerUsername: string;
    /**
     * Docker registry password
     * @type {string}
     * @memberof Cluster
     */
    dockerPassword: string;
    /**
     * Docker registry URL. Dockerhub is used by default.
     * @type {string}
     * @memberof Cluster
     */
    dockerRegistry?: string;
    /**
     * Storage class to use for datasets
     * @type {string}
     * @memberof Cluster
     */
    storageClass?: string;
    /**
     * Readiness of the cluster
     * @type {boolean}
     * @memberof Cluster
     */
    status?: boolean;
    /**
     * Name of the workflow used to setup grader
     * @type {string}
     * @memberof Cluster
     */
    wfName?: string;
    /**
     * User ID
     * @type {number}
     * @memberof Cluster
     */
    userId?: number;
    /**
     * Organisation ID
     * @type {number}
     * @memberof Cluster
     */
    organisationId?: number;
}

/**
 * 
 * @export
 * @interface Grader
 */
export interface Grader {
    /**
     * ID
     * @type {number}
     * @memberof Grader
     */
    id?: number;
    /**
     * Creation time
     * @type {Date}
     * @memberof Grader
     */
    created?: Date;
    /**
     * Last updation time
     * @type {Date}
     * @memberof Grader
     */
    updated?: Date;
    /**
     * Dataset metadata
     * @type {any}
     * @memberof Grader
     */
    dataset?: any;
    /**
     * Cluster to run the grader on
     * @type {number}
     * @memberof Grader
     */
    clusterId?: number;
    /**
     * Description of the grader
     * @type {string}
     * @memberof Grader
     */
    description?: string;
    /**
     * Argo workflow template spec
     * @type {any}
     * @memberof Grader
     */
    workflowSpec?: any;
    /**
     * Git URL of the repository containing the code that will be used for the evaluation
     * @type {string}
     * @memberof Grader
     */
    evaluatorRepo: string;
    /**
     * Git branch/tag that should be used with the evaluator repository.
     * @type {string}
     * @memberof Grader
     */
    evaluatorRepoTag?: string;
    /**
     * Name of the grader
     * @type {string}
     * @memberof Grader
     */
    name?: string;
    /**
     * Notifications available for the grader.
     * @type {string}
     * @memberof Grader
     */
    notifications?: string;
    /**
     * Logs from argo workflow
     * @type {string}
     * @memberof Grader
     */
    logs?: string;
    /**
     * Additional meta data of the grader
     * @type {string}
     * @memberof Grader
     */
    meta?: string;
    /**
     * Status of the grader - True if it ready, False otherwise
     * @type {string}
     * @memberof Grader
     */
    status?: string;
    /**
     * List of key:value pair of secrets that will be replace `{key}` in aicrowd.yaml
     * @type {any}
     * @memberof Grader
     */
    secrets?: any;
    /**
     * Name of the workflow used to setup grader
     * @type {string}
     * @memberof Grader
     */
    wfName?: string;
    /**
     * Type of submissions allowed on the grader
     * @type {any}
     * @memberof Grader
     */
    submissionTypes?: any;
    /**
     * User ID
     * @type {number}
     * @memberof Grader
     */
    userId?: number;
    /**
     * Organisation ID
     * @type {number}
     * @memberof Grader
     */
    organisationId?: number;
}

/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * Email address of the user
     * @type {string}
     * @memberof Login
     */
    email: string;
    /**
     * Password corresponding to the Email address
     * @type {string}
     * @memberof Login
     */
    password: string;
}

/**
 * 
 * @export
 * @interface Organisation
 */
export interface Organisation {
    /**
     * ID
     * @type {number}
     * @memberof Organisation
     */
    id?: number;
    /**
     * Organisation Name
     * @type {string}
     * @memberof Organisation
     */
    name: string;
    /**
     * Point of contact email
     * @type {string}
     * @memberof Organisation
     */
    pocEmail: string;
    /**
     * Creation Time
     * @type {Date}
     * @memberof Organisation
     */
    createdOn?: Date;
    /**
     * Total assigned evaluation quota
     * @type {number}
     * @memberof Organisation
     */
    totalQuota?: number;
    /**
     * Available evaluation quota
     * @type {number}
     * @memberof Organisation
     */
    quota?: number;
}

/**
 * 
 * @export
 * @interface OrganisationQuota
 */
export interface OrganisationQuota {
    /**
     * Quota to be added or reduced
     * @type {number}
     * @memberof OrganisationQuota
     */
    quota: number;
}

/**
 * 
 * @export
 * @interface Submissions
 */
export interface Submissions {
    /**
     * ID
     * @type {number}
     * @memberof Submissions
     */
    id?: number;
    /**
     * Creation time
     * @type {Date}
     * @memberof Submissions
     */
    created?: Date;
    /**
     * Last updation time
     * @type {Date}
     * @memberof Submissions
     */
    updated?: Date;
    /**
     * Grader identifier
     * @type {number}
     * @memberof Submissions
     */
    graderId: number;
    /**
     * URL to the submission code
     * @type {any}
     * @memberof Submissions
     */
    submissionData?: any;
    /**
     * Current status of the submission
     * @type {string}
     * @memberof Submissions
     */
    status?: string;
    /**
     * S3 link of the output (available after the evaluation)
     * @type {string}
     * @memberof Submissions
     */
    output?: string;
    /**
     * Array of any additional outputs
     * @type {any}
     * @memberof Submissions
     */
    additionalOutputs?: any;
    /**
     * S3 link of the STDOUT of the evaluation
     * @type {string}
     * @memberof Submissions
     */
    logs?: string;
    /**
     * Evaluation start time
     * @type {Date}
     * @memberof Submissions
     */
    started?: Date;
    /**
     * Evaluation end time
     * @type {Date}
     * @memberof Submissions
     */
    ended?: Date;
    /**
     * Additional meta data of the grader
     * @type {string}
     * @memberof Submissions
     */
    meta?: string;
    /**
     * Name of the workflow used to evaluate submission
     * @type {string}
     * @memberof Submissions
     */
    wfName?: string;
    /**
     * User ID
     * @type {number}
     * @memberof Submissions
     */
    userId?: number;
    /**
     * Organisation ID
     * @type {number}
     * @memberof Submissions
     */
    organisationId?: number;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * ID
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * Email
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * Admin Boolean
     * @type {boolean}
     * @memberof User
     */
    admin?: boolean;
    /**
     * Creation Time
     * @type {Date}
     * @memberof User
     */
    createdOn?: Date;
    /**
     * Hashed Password
     * @type {string}
     * @memberof User
     */
    passwordHash?: string;
    /**
     * Total assigned evaluation quota
     * @type {number}
     * @memberof User
     */
    totalQuota?: number;
    /**
     * Available evaluation quota
     * @type {number}
     * @memberof User
     */
    quota?: number;
    /**
     * Organisation identifier
     * @type {number}
     * @memberof User
     */
    organisationId: number;
    /**
     * user password
     * @type {string}
     * @memberof User
     */
    password: string;
}

/**
 * 
 * @export
 * @interface UserQuota
 */
export interface UserQuota {
    /**
     * Quota to be added or reduced
     * @type {number}
     * @memberof UserQuota
     */
    quota: number;
}


/**
 * AuthApi - fetch parameter creator
 * @export
 */
export const AuthApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Log in a user with email and password.
         * @param {Login} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(payload: Login, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling login.');
            }
            const localVarPath = `/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Login" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidate the current authorization token.
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/auth/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Log in a user with email and password.
         * @param {Login} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(payload: Login, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthResponse> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).login(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Invalidate the current authorization token.
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthLogout> {
            const localVarFetchArgs = AuthApiFetchParamCreator(configuration).logout(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Log in a user with email and password.
         * @param {Login} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(payload: Login, xFields?: string, options?: any) {
            return AuthApiFp(configuration).login(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Invalidate the current authorization token.
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(xFields?: string, options?: any) {
            return AuthApiFp(configuration).logout(xFields, options)(fetch, basePath);
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Log in a user with email and password.
     * @param {Login} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public login(payload: Login, xFields?: string, options?: any) {
        return AuthApiFp(this.configuration).login(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Invalidate the current authorization token.
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(xFields?: string, options?: any) {
        return AuthApiFp(this.configuration).logout(xFields, options)(this.fetch, this.basePath);
    }

}

/**
 * ClustersApi - fetch parameter creator
 * @export
 */
export const ClustersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new cluster to AIcrowd and install necessary dependencies
         * @param {Cluster} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(payload: Cluster, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createCluster.');
            }
            const localVarPath = `/clusters/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Cluster" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a cluster by its ID
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(clusterId: number, options: any = {}): FetchArgs {
            // verify required parameter 'clusterId' is not null or undefined
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling deleteCluster.');
            }
            const localVarPath = `/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a cluster by its ID
         * @param {number} clusterId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(clusterId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'clusterId' is not null or undefined
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling getCluster.');
            }
            const localVarPath = `/clusters/{cluster_id}`
                .replace(`{${"cluster_id"}}`, encodeURIComponent(String(clusterId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all clusters available
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/clusters/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a new cluster to AIcrowd and install necessary dependencies
         * @param {Cluster} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(payload: Cluster, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cluster> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).createCluster(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a cluster by its ID
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(clusterId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).deleteCluster(clusterId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details of a cluster by its ID
         * @param {number} clusterId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(clusterId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Cluster> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).getCluster(clusterId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all clusters available
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cluster>> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).listClusters(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add a new cluster to AIcrowd and install necessary dependencies
         * @param {Cluster} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCluster(payload: Cluster, xFields?: string, options?: any) {
            return ClustersApiFp(configuration).createCluster(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Delete a cluster by its ID
         * @param {number} clusterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCluster(clusterId: number, options?: any) {
            return ClustersApiFp(configuration).deleteCluster(clusterId, options)(fetch, basePath);
        },
        /**
         * Get details of a cluster by its ID
         * @param {number} clusterId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCluster(clusterId: number, xFields?: string, options?: any) {
            return ClustersApiFp(configuration).getCluster(clusterId, xFields, options)(fetch, basePath);
        },
        /**
         * List all clusters available
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listClusters(xFields?: string, options?: any) {
            return ClustersApiFp(configuration).listClusters(xFields, options)(fetch, basePath);
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * Add a new cluster to AIcrowd and install necessary dependencies
     * @param {Cluster} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public createCluster(payload: Cluster, xFields?: string, options?: any) {
        return ClustersApiFp(this.configuration).createCluster(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a cluster by its ID
     * @param {number} clusterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public deleteCluster(clusterId: number, options?: any) {
        return ClustersApiFp(this.configuration).deleteCluster(clusterId, options)(this.fetch, this.basePath);
    }

    /**
     * Get details of a cluster by its ID
     * @param {number} clusterId 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public getCluster(clusterId: number, xFields?: string, options?: any) {
        return ClustersApiFp(this.configuration).getCluster(clusterId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * List all clusters available
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public listClusters(xFields?: string, options?: any) {
        return ClustersApiFp(this.configuration).listClusters(xFields, options)(this.fetch, this.basePath);
    }

}

/**
 * GradersApi - fetch parameter creator
 * @export
 */
export const GradersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new grader
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrader(payload: Grader, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createGrader.');
            }
            const localVarPath = `/graders/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Grader" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a grader by its ID
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrader(graderId: number, options: any = {}): FetchArgs {
            // verify required parameter 'graderId' is not null or undefined
            if (graderId === null || graderId === undefined) {
                throw new RequiredError('graderId','Required parameter graderId was null or undefined when calling deleteGrader.');
            }
            const localVarPath = `/graders/{grader_id}`
                .replace(`{${"grader_id"}}`, encodeURIComponent(String(graderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a grader by its ID
         * @param {number} graderId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrader(graderId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'graderId' is not null or undefined
            if (graderId === null || graderId === undefined) {
                throw new RequiredError('graderId','Required parameter graderId was null or undefined when calling getGrader.');
            }
            const localVarPath = `/graders/{grader_id}`
                .replace(`{${"grader_id"}}`, encodeURIComponent(String(graderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the grader logs by submission ID
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderLogs(graderId: number, options: any = {}): FetchArgs {
            // verify required parameter 'graderId' is not null or undefined
            if (graderId === null || graderId === undefined) {
                throw new RequiredError('graderId','Required parameter graderId was null or undefined when calling getGraderLogs.');
            }
            const localVarPath = `/graders/{grader_id}/logs`
                .replace(`{${"grader_id"}}`, encodeURIComponent(String(graderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all graders available
         * @param {string} [name] Fetch grader with this name
         * @param {string} [status] Fetch graders with this status
         * @param {number} [userId] Fetch graders created by the user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraders(name?: string, status?: string, userId?: number, xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/graders/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GradersApi - functional programming interface
 * @export
 */
export const GradersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new grader
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrader(payload: Grader, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Grader> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).createGrader(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a grader by its ID
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrader(graderId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).deleteGrader(graderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details of a grader by its ID
         * @param {number} graderId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrader(graderId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Grader> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).getGrader(graderId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the grader logs by submission ID
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderLogs(graderId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).getGraderLogs(graderId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all graders available
         * @param {string} [name] Fetch grader with this name
         * @param {string} [status] Fetch graders with this status
         * @param {number} [userId] Fetch graders created by the user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraders(name?: string, status?: string, userId?: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Grader>> {
            const localVarFetchArgs = GradersApiFetchParamCreator(configuration).listGraders(name, status, userId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GradersApi - factory interface
 * @export
 */
export const GradersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new grader
         * @param {Grader} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGrader(payload: Grader, xFields?: string, options?: any) {
            return GradersApiFp(configuration).createGrader(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Delete a grader by its ID
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGrader(graderId: number, options?: any) {
            return GradersApiFp(configuration).deleteGrader(graderId, options)(fetch, basePath);
        },
        /**
         * Get details of a grader by its ID
         * @param {number} graderId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrader(graderId: number, xFields?: string, options?: any) {
            return GradersApiFp(configuration).getGrader(graderId, xFields, options)(fetch, basePath);
        },
        /**
         * Get the grader logs by submission ID
         * @param {number} graderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraderLogs(graderId: number, options?: any) {
            return GradersApiFp(configuration).getGraderLogs(graderId, options)(fetch, basePath);
        },
        /**
         * List all graders available
         * @param {string} [name] Fetch grader with this name
         * @param {string} [status] Fetch graders with this status
         * @param {number} [userId] Fetch graders created by the user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGraders(name?: string, status?: string, userId?: number, xFields?: string, options?: any) {
            return GradersApiFp(configuration).listGraders(name, status, userId, xFields, options)(fetch, basePath);
        },
    };
};

/**
 * GradersApi - object-oriented interface
 * @export
 * @class GradersApi
 * @extends {BaseAPI}
 */
export class GradersApi extends BaseAPI {
    /**
     * Create a new grader
     * @param {Grader} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public createGrader(payload: Grader, xFields?: string, options?: any) {
        return GradersApiFp(this.configuration).createGrader(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a grader by its ID
     * @param {number} graderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public deleteGrader(graderId: number, options?: any) {
        return GradersApiFp(this.configuration).deleteGrader(graderId, options)(this.fetch, this.basePath);
    }

    /**
     * Get details of a grader by its ID
     * @param {number} graderId 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public getGrader(graderId: number, xFields?: string, options?: any) {
        return GradersApiFp(this.configuration).getGrader(graderId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Get the grader logs by submission ID
     * @param {number} graderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public getGraderLogs(graderId: number, options?: any) {
        return GradersApiFp(this.configuration).getGraderLogs(graderId, options)(this.fetch, this.basePath);
    }

    /**
     * List all graders available
     * @param {string} [name] Fetch grader with this name
     * @param {string} [status] Fetch graders with this status
     * @param {number} [userId] Fetch graders created by the user
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GradersApi
     */
    public listGraders(name?: string, status?: string, userId?: number, xFields?: string, options?: any) {
        return GradersApiFp(this.configuration).listGraders(name, status, userId, xFields, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganisationsApi - fetch parameter creator
 * @export
 */
export const OrganisationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new organisation
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganisation(payload: Organisation, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createOrganisation.');
            }
            const localVarPath = `/organisations/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organisation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an Organisation
         * @param {number} organisationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganisation(organisationId: number, options: any = {}): FetchArgs {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling deleteOrganisation.');
            }
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an organisation
         * @param {number} organisationId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation(organisationId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling getOrganisation.');
            }
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all organisations
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganisations(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/organisations/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Organisation
         * @param {number} organisationId 
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganisation(organisationId: number, payload: Organisation, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling updateOrganisation.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateOrganisation.');
            }
            const localVarPath = `/organisations/{organisation_id}`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Organisation" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or subtract quota for an organisation
         * @param {number} organisationId 
         * @param {OrganisationQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganisationQuota(organisationId: number, payload: OrganisationQuota, options: any = {}): FetchArgs {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling updateOrganisationQuota.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateOrganisationQuota.');
            }
            const localVarPath = `/organisations/{organisation_id}/addquota`
                .replace(`{${"organisation_id"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"OrganisationQuota" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganisationsApi - functional programming interface
 * @export
 */
export const OrganisationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new organisation
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganisation(payload: Organisation, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organisation> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).createOrganisation(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an Organisation
         * @param {number} organisationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganisation(organisationId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).deleteOrganisation(organisationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details of an organisation
         * @param {number} organisationId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation(organisationId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organisation> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).getOrganisation(organisationId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all organisations
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganisations(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Organisation>> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).listOrganisations(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an Organisation
         * @param {number} organisationId 
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganisation(organisationId: number, payload: Organisation, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Organisation> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).updateOrganisation(organisationId, payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add or subtract quota for an organisation
         * @param {number} organisationId 
         * @param {OrganisationQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganisationQuota(organisationId: number, payload: OrganisationQuota, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrganisationsApiFetchParamCreator(configuration).updateOrganisationQuota(organisationId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganisationsApi - factory interface
 * @export
 */
export const OrganisationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new organisation
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganisation(payload: Organisation, xFields?: string, options?: any) {
            return OrganisationsApiFp(configuration).createOrganisation(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Delete an Organisation
         * @param {number} organisationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganisation(organisationId: number, options?: any) {
            return OrganisationsApiFp(configuration).deleteOrganisation(organisationId, options)(fetch, basePath);
        },
        /**
         * Get details of an organisation
         * @param {number} organisationId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganisation(organisationId: number, xFields?: string, options?: any) {
            return OrganisationsApiFp(configuration).getOrganisation(organisationId, xFields, options)(fetch, basePath);
        },
        /**
         * List all organisations
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrganisations(xFields?: string, options?: any) {
            return OrganisationsApiFp(configuration).listOrganisations(xFields, options)(fetch, basePath);
        },
        /**
         * Update an Organisation
         * @param {number} organisationId 
         * @param {Organisation} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganisation(organisationId: number, payload: Organisation, xFields?: string, options?: any) {
            return OrganisationsApiFp(configuration).updateOrganisation(organisationId, payload, xFields, options)(fetch, basePath);
        },
        /**
         * Add or subtract quota for an organisation
         * @param {number} organisationId 
         * @param {OrganisationQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganisationQuota(organisationId: number, payload: OrganisationQuota, options?: any) {
            return OrganisationsApiFp(configuration).updateOrganisationQuota(organisationId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * OrganisationsApi - object-oriented interface
 * @export
 * @class OrganisationsApi
 * @extends {BaseAPI}
 */
export class OrganisationsApi extends BaseAPI {
    /**
     * Create a new organisation
     * @param {Organisation} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public createOrganisation(payload: Organisation, xFields?: string, options?: any) {
        return OrganisationsApiFp(this.configuration).createOrganisation(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an Organisation
     * @param {number} organisationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public deleteOrganisation(organisationId: number, options?: any) {
        return OrganisationsApiFp(this.configuration).deleteOrganisation(organisationId, options)(this.fetch, this.basePath);
    }

    /**
     * Get details of an organisation
     * @param {number} organisationId 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public getOrganisation(organisationId: number, xFields?: string, options?: any) {
        return OrganisationsApiFp(this.configuration).getOrganisation(organisationId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * List all organisations
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public listOrganisations(xFields?: string, options?: any) {
        return OrganisationsApiFp(this.configuration).listOrganisations(xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Update an Organisation
     * @param {number} organisationId 
     * @param {Organisation} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public updateOrganisation(organisationId: number, payload: Organisation, xFields?: string, options?: any) {
        return OrganisationsApiFp(this.configuration).updateOrganisation(organisationId, payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Add or subtract quota for an organisation
     * @param {number} organisationId 
     * @param {OrganisationQuota} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganisationsApi
     */
    public updateOrganisationQuota(organisationId: number, payload: OrganisationQuota, options?: any) {
        return OrganisationsApiFp(this.configuration).updateOrganisationQuota(organisationId, payload, options)(this.fetch, this.basePath);
    }

}

/**
 * SubmissionsApi - fetch parameter creator
 * @export
 */
export const SubmissionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Make a new submission
         * @param {Submissions} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission(payload: Submissions, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createSubmission.');
            }
            const localVarPath = `/submissions/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Submissions" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop evaluation of a submission and delete it
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling deleteSubmission.');
            }
            const localVarPath = `/submissions/{submission_id}`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a submission by its ID
         * @param {number} submissionId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmission(submissionId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling getSubmission.');
            }
            const localVarPath = `/submissions/{submission_id}`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the submission data by submission ID
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionData(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling getSubmissionData.');
            }
            const localVarPath = `/submissions/{submission_id}/data`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the submission logs by submission ID
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionLogs(submissionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'submissionId' is not null or undefined
            if (submissionId === null || submissionId === undefined) {
                throw new RequiredError('submissionId','Required parameter submissionId was null or undefined when calling getSubmissionLogs.');
            }
            const localVarPath = `/submissions/{submission_id}/logs`
                .replace(`{${"submission_id"}}`, encodeURIComponent(String(submissionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all submissions available
         * @param {string} [meta] Fetch submissions with this meta value
         * @param {string} [status] Fetch submissions with this status
         * @param {number} [userId] Fetch submissions created by the user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubmissions(meta?: string, status?: string, userId?: number, xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/submissions/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (meta !== undefined) {
                localVarQueryParameter['meta'] = meta;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubmissionsApi - functional programming interface
 * @export
 */
export const SubmissionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Make a new submission
         * @param {Submissions} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission(payload: Submissions, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).createSubmission(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Stop evaluation of a submission and delete it
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).deleteSubmission(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get details of a submission by its ID
         * @param {number} submissionId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmission(submissionId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Submissions> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).getSubmission(submissionId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the submission data by submission ID
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionData(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).getSubmissionData(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the submission logs by submission ID
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionLogs(submissionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).getSubmissionLogs(submissionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all submissions available
         * @param {string} [meta] Fetch submissions with this meta value
         * @param {string} [status] Fetch submissions with this status
         * @param {number} [userId] Fetch submissions created by the user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubmissions(meta?: string, status?: string, userId?: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Submissions>> {
            const localVarFetchArgs = SubmissionsApiFetchParamCreator(configuration).listSubmissions(meta, status, userId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubmissionsApi - factory interface
 * @export
 */
export const SubmissionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Make a new submission
         * @param {Submissions} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubmission(payload: Submissions, xFields?: string, options?: any) {
            return SubmissionsApiFp(configuration).createSubmission(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Stop evaluation of a submission and delete it
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubmission(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).deleteSubmission(submissionId, options)(fetch, basePath);
        },
        /**
         * Get details of a submission by its ID
         * @param {number} submissionId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmission(submissionId: number, xFields?: string, options?: any) {
            return SubmissionsApiFp(configuration).getSubmission(submissionId, xFields, options)(fetch, basePath);
        },
        /**
         * Get the submission data by submission ID
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionData(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).getSubmissionData(submissionId, options)(fetch, basePath);
        },
        /**
         * Get the submission logs by submission ID
         * @param {number} submissionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubmissionLogs(submissionId: number, options?: any) {
            return SubmissionsApiFp(configuration).getSubmissionLogs(submissionId, options)(fetch, basePath);
        },
        /**
         * List all submissions available
         * @param {string} [meta] Fetch submissions with this meta value
         * @param {string} [status] Fetch submissions with this status
         * @param {number} [userId] Fetch submissions created by the user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSubmissions(meta?: string, status?: string, userId?: number, xFields?: string, options?: any) {
            return SubmissionsApiFp(configuration).listSubmissions(meta, status, userId, xFields, options)(fetch, basePath);
        },
    };
};

/**
 * SubmissionsApi - object-oriented interface
 * @export
 * @class SubmissionsApi
 * @extends {BaseAPI}
 */
export class SubmissionsApi extends BaseAPI {
    /**
     * Make a new submission
     * @param {Submissions} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public createSubmission(payload: Submissions, xFields?: string, options?: any) {
        return SubmissionsApiFp(this.configuration).createSubmission(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Stop evaluation of a submission and delete it
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public deleteSubmission(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).deleteSubmission(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get details of a submission by its ID
     * @param {number} submissionId 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public getSubmission(submissionId: number, xFields?: string, options?: any) {
        return SubmissionsApiFp(this.configuration).getSubmission(submissionId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Get the submission data by submission ID
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public getSubmissionData(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).getSubmissionData(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * Get the submission logs by submission ID
     * @param {number} submissionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public getSubmissionLogs(submissionId: number, options?: any) {
        return SubmissionsApiFp(this.configuration).getSubmissionLogs(submissionId, options)(this.fetch, this.basePath);
    }

    /**
     * List all submissions available
     * @param {string} [meta] Fetch submissions with this meta value
     * @param {string} [status] Fetch submissions with this status
     * @param {number} [userId] Fetch submissions created by the user
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubmissionsApi
     */
    public listSubmissions(meta?: string, status?: string, userId?: number, xFields?: string, options?: any) {
        return SubmissionsApiFp(this.configuration).listSubmissions(meta, status, userId, xFields, options)(this.fetch, this.basePath);
    }

}

/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new user
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(payload: User, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling createUser.');
            }
            const localVarPath = `/users/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information of a user
         * @param {number} userId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(xFields?: string, options: any = {}): FetchArgs {
            const localVarPath = `/users/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user
         * @param {number} userId 
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: number, payload: User, xFields?: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            if (xFields !== undefined && xFields !== null) {
                localVarHeaderParameter['X-Fields'] = String(xFields);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add or subtract quota for a user
         * @param {number} userId 
         * @param {UserQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserQuota(userId: number, payload: UserQuota, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUserQuota.');
            }
            // verify required parameter 'payload' is not null or undefined
            if (payload === null || payload === undefined) {
                throw new RequiredError('payload','Required parameter payload was null or undefined when calling updateUserQuota.');
            }
            const localVarPath = `/users/{user_id}/addquota`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("AUTHORIZATION")
					: configuration.apiKey;
                localVarHeaderParameter["AUTHORIZATION"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserQuota" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(payload || {}) : (payload || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new user
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(payload: User, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information of a user
         * @param {number} userId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUser(userId, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listUsers(xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a user
         * @param {number} userId 
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: number, payload: User, xFields?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(userId, payload, xFields, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Add or subtract quota for a user
         * @param {number} userId 
         * @param {UserQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserQuota(userId: number, payload: UserQuota, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUserQuota(userId, payload, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new user
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(payload: User, xFields?: string, options?: any) {
            return UsersApiFp(configuration).createUser(payload, xFields, options)(fetch, basePath);
        },
        /**
         * Delete a user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: number, options?: any) {
            return UsersApiFp(configuration).deleteUser(userId, options)(fetch, basePath);
        },
        /**
         * Get information of a user
         * @param {number} userId 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, xFields?: string, options?: any) {
            return UsersApiFp(configuration).getUser(userId, xFields, options)(fetch, basePath);
        },
        /**
         * Get all user
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(xFields?: string, options?: any) {
            return UsersApiFp(configuration).listUsers(xFields, options)(fetch, basePath);
        },
        /**
         * Update a user
         * @param {number} userId 
         * @param {User} payload 
         * @param {string} [xFields] An optional fields mask
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: number, payload: User, xFields?: string, options?: any) {
            return UsersApiFp(configuration).updateUser(userId, payload, xFields, options)(fetch, basePath);
        },
        /**
         * Add or subtract quota for a user
         * @param {number} userId 
         * @param {UserQuota} payload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserQuota(userId: number, payload: UserQuota, options?: any) {
            return UsersApiFp(configuration).updateUserQuota(userId, payload, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Create a new user
     * @param {User} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(payload: User, xFields?: string, options?: any) {
        return UsersApiFp(this.configuration).createUser(payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a user
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(userId: number, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Get information of a user
     * @param {number} userId 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: number, xFields?: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Get all user
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listUsers(xFields?: string, options?: any) {
        return UsersApiFp(this.configuration).listUsers(xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Update a user
     * @param {number} userId 
     * @param {User} payload 
     * @param {string} [xFields] An optional fields mask
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: number, payload: User, xFields?: string, options?: any) {
        return UsersApiFp(this.configuration).updateUser(userId, payload, xFields, options)(this.fetch, this.basePath);
    }

    /**
     * Add or subtract quota for a user
     * @param {number} userId 
     * @param {UserQuota} payload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUserQuota(userId: number, payload: UserQuota, options?: any) {
        return UsersApiFp(this.configuration).updateUserQuota(userId, payload, options)(this.fetch, this.basePath);
    }

}

